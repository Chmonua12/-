# Банк вопросов по программированию на языке C

## 1. Основы языка C

#### 1. Какой тип данных в языке C используется для хранения одного символа?
Тип `char` используется для хранения одного символа. Он занимает 1 байт (8 бит) памяти и может хранить значения от -128 до 127 (signed char) или от 0 до 255 (unsigned char).

#### 2. Чему равен размер типа int на большинстве современных 64-битных систем?
На большинстве современных 64-битных систем размер типа `int` равен 4 байта (32 бита). Однако это зависит от компилятора и платформы - стандарт C гарантирует только, что `int` будет не меньше `short` и не больше `long`.

#### 3. Какое значение примет переменная x после выполнения: `unsigned char x = 256;`?
Переменная примет значение 0. Тип `unsigned char` может хранить значения от 0 до 255 (1 байт). При присвоении значения 256 происходит переполнение, и сохраняется остаток от деления на 256 (256 % 256 = 0).

#### 4. Можно ли в C присвоить значение переменной без её предварительного объявления? Почему?
Нет, нельзя. В языке C все переменные должны быть объявлены перед использованием. Компилятору необходимо знать тип переменной, чтобы выделить соответствующее количество памяти и правильно интерпретировать операции с этой переменной.

#### 5. Что выведет программа:
```c
int a = 5, b = 2;
printf("%d", a / b);
```
Программа выведет `2`. При делении целых чисел (`int`) результат тоже целый. Дробная часть отбрасывается (не округляется).

#### 6. Как объявить константу времени компиляции с помощью #define для числа π с точностью до 5 знаков?
```c
#define PI 3.14159
```
Директива `#define` создаёт макроподстановку - текст PI будет заменён на 3.14159 на этапе препроцессинга.

#### 7. В чём разница между float и double по памяти и точности?
- `float`: 4 байта (32 бита), точность примерно 6-7 значащих цифр
- `double`: 8 байт (64 бита), точность примерно 15-16 значащих цифр
`double` обеспечивает большую точность и диапазон значений за счёт использования большего количества памяти.

#### 8. Что произойдёт, если использовать %d в printf для вывода переменной типа double?
Будет выведено неопределённое (мусорное) значение. Спецификатор формата `%d` ожидает аргумент типа `int`, а передаётся `double`. Это приводит к неопределённому поведению (undefined behavior), так как интерпретация байтов в стеке будет некорректной.

#### 9. Как проверить, является ли введённое число чётным, используя побитовую операцию?
```c
int number;
if ((number & 1) == 0) {
    // число чётное
}
```
Проверка использует побитовое И (`&`) с единицей. У чётных чисел младший бит равен 0, у нечётных - 1.

#### 10. Какой результат даст выражение: `(1 << 3) + (1 << 1)`?
Результат: `10` (в десятичной системе).
- `1 << 3` = 8 (битовый сдвиг влево на 3 позиции)
- `1 << 1` = 2 (битовый сдвиг влево на 1 позицию)
- `8 + 2 = 10`

#### 11. Что выведет код:
```c
int x = -5;
printf("%u", x);
```
Будет выведено большое положительное число (обычно 4294967291 на 32-битных системах). Спецификатор `%u` ожидает `unsigned int`, а передаётся `int` со значением -5. Отрицательное число интерпретируется как беззнаковое, что даёт некорректный результат.

#### 12. Можно ли в C изменить значение, объявленное с const? Приведите пример.
Формально - нет, но технически можно обойти это ограничение через указатели:
```c
const int x = 10;
int* p = (int*)&x;  // явное приведение типа
*p = 20;            // неопределённое поведение!
printf("%d", x);    // результат непредсказуем
```
Это приводит к неопределённому поведению и может вызвать ошибки сегментации или неожиданные результаты.

#### 13. Какой тип использовать, если нужно гарантировать, что переменная занимает ровно 4 байта?
Использовать типы из `<stdint.h>`:
```c
#include <stdint.h>
int32_t variable;  // гарантировано 4 байта, знаковое
uint32_t uvariable; // гарантировано 4 байта, беззнаковое
```
Эти типы гарантируют определённый размер независимо от платформы.

#### 14. Что такое typedef и зачем он используется? Приведите пример.
`typedef` создаёт псевдоним (алиас) для существующего типа:
```c
typedef unsigned int uint;
typedef char* String;
typedef struct {
    int x, y;
} Point;

uint count = 10;      // вместо unsigned int
String name = "John"; // вместо char*
Point p = {1, 2};     // вместо struct {...}
```
Упрощает чтение кода, скрывает сложные объявления, повышает переносимость.

#### 15. В чём разница между signed char и unsigned char при выводе через %c и %d?
- `%c`: выводят одинаково - как символ
- `%d`: `signed char` выводится как число от -128 до 127, `unsigned char` - как число от 0 до 255
```c
signed char sc = -65;
unsigned char uc = 191;
printf("%c %c\n", sc, uc);  // оба выведут символ (одинаковый байт)
printf("%d %d\n", sc, uc);  // -65 191
```

## 2. Массивы

#### 16. Можно ли в C присвоить один массив другому с помощью оператора =? Почему?
Нет, нельзя. Массивы в C не поддерживают операцию присваивания. Для копирования массива нужно использовать функции типа `memcpy()` или копировать элементы в цикле:
```c
int arr1[5] = {1, 2, 3, 4, 5};
int arr2[5];
// arr2 = arr1; // ОШИБКА!
memcpy(arr2, arr1, sizeof(arr1)); // правильно
```

#### 17. Как передать массив в функцию? Какой тип параметра указать?
Массив передаётся как указатель на его первый элемент:
```c
void func(int arr[], int size);    // вариант 1
void func(int* arr, int size);     // вариант 2 (предпочтительнее)
```
Оба варианта эквивалентны - компилятор преобразует `int arr[]` в `int* arr`.

#### 18. Как найти длину массива, известного внутри функции, если он передан как параметр?
Нельзя определить длину массива, переданного как параметр, если она не передана отдельно. Оператор `sizeof` вернёт размер указателя, а не массива:
```c
void func(int arr[]) {
    // sizeof(arr) вернёт размер указателя (например, 8 байт на 64-битной системе)
    // НЕ размер массива в байтах!
}
```
Длину нужно передавать отдельным параметром.

#### 19. Объявите структуру Point с полями x и y типа double.
```c
struct Point {
    double x;
    double y;
};
```
Или с использованием typedef:
```c
typedef struct {
    double x;
    double y;
} Point;
```

#### 20. Как получить доступ к полю структуры через указатель?
Два способа:
```c
struct Point p;
struct Point* ptr = &p;

(*ptr).x = 10.0;  // способ 1
ptr->y = 20.0;    // способ 2 (предпочтительнее)
```
Оператор `->` является синтаксическим сахаром для `(*ptr).`.

#### 21. В чём принципиальное отличие union от struct по использованию памяти?
- `struct`: все поля хранятся в отдельных областях памяти, размер = сумме размеров всех полей (с выравниванием)
- `union`: все поля разделяют одну область памяти, размер = размеру наибольшего поля

#### 22. Объявите объединение, содержащее int, float и char[4]. Чему будет равен sizeof этого объединения?
```c
union Data {
    int i;
    float f;
    char arr[4];
};
```
`sizeof(union Data)` будет равен 4 байта (на большинстве систем), так как это размер наибольшего поля (int, float и char[4] все по 4 байта).

#### 23. Можно ли инициализировать все поля union сразу? Почему?
Нет, нельзя. В union в любой момент времени активно только одно поле. При инициализации можно указать только первое поле:
```c
union Data u = {10};  // инициализирует поле i
```
Или использовать именованную инициализацию (в C99 и новее):
```c
union Data u = {.f = 3.14f};
```

#### 24. Какие поля структуры будут неинициализированными, если структура объявлена как static?
Все поля static-структуры инициализируются нулями автоматически:
```c
static struct Example {
    int a;
    char b;
    float c;
} s;  // s.a = 0, s.b = '\0', s.c = 0.0f
```
Это отличие от автоматических (локальных) структур, которые содержат мусор.

#### 25. Как объявить массив из 10 структур Student с полями name[50] и age?
```c
struct Student {
    char name[50];
    int age;
};

struct Student students[10];
```
Или с инициализацией:
```c
struct Student students[10] = {
    {"Alice", 20},
    {"Bob", 21},
    // остальные элементы будут нулевыми
};
```

#### 26. Как передать структуру в функцию, чтобы избежать копирования?
Передать по указателю:
```c
void processStudent(struct Student* student) {
    // работа через указатель
    printf("%s", student->name);
}
```
Или по константному указателю, если структура не будет изменяться:
```c
void printStudent(const struct Student* student) {
    printf("Name: %s, Age: %d", student->name, student->age);
}
```

#### 27. В чём опасность использования struct без указания размера массива внутри?
Если массив в структуре объявлен без размера (flexible array member), то:
1. Такая структура не может быть статически инициализирована
2. При выделении памяти нужно учитывать размер массива
3. `sizeof` не включает размер гибкого массива
```c
struct Buffer {
    int length;
    char data[];  // гибкий массив
};
```

#### 28. Как инициализировать массив структур при объявлении?
```c
struct Point {
    int x, y;
};

struct Point points[3] = {
    {1, 2},
    {3, 4},
    {5, 6}
};
```
В C99+ можно использовать именованную инициализацию:
```c
struct Point points[3] = {
    [0] = {1, 2},
    [2] = {5, 6}  // points[1] будет нулевой
};
```

#### 29. Можно ли в C объявить массив переменной длины (VLA) как глобальную переменную? Почему?
Нет, нельзя. Массивы переменной длины (Variable Length Arrays) могут быть объявлены только внутри функций (в стековом кадре). Их размер определяется во время выполнения, а глобальные переменные размещаются в статической памяти, размер которой должен быть известен на этапе компиляции.

#### 30. Как объявить массив указателей на структуры Book размером 100?
```c
struct Book* books[100];
```
Это объявляет массив из 100 указателей на `struct Book`. Каждый элемент нужно инициализировать отдельно, например, через `malloc()`.

## 3. Указатели

#### 31. Что хранится в переменной, объявленной как `int* p;`?
Переменная `p` хранит адрес ячейки памяти, в которой находится (или будет находиться) значение типа `int`. Само значение `int` получается разыменованием указателя: `*p`.

#### 32. Как получить адрес переменной x?
С помощью оператора взятия адреса `&`:
```c
int x = 42;
int* ptr = &x;  // ptr теперь содержит адрес x
```

#### 33. Что выведет код:
```c
int a = 42;
int* p = &a;
printf("%d", *p);
```
Выведет `42`. `*p` разыменовывает указатель, получая значение переменной `a`.

#### 34. Что означает выражение `*(arr + i)` и как оно связано с `arr[i]`?
Выражения `*(arr + i)` и `arr[i]` полностью эквивалентны в языке C. Оба:
1. Берут базовый адрес массива `arr`
2. Добавляют смещение `i * sizeof(тип_элемента)` байт
3. Разыменовывают полученный адрес

#### 35. Можно ли выполнять арифметику над указателем на void? Почему?
Нет, стандартный C не позволяет арифметику над `void*`, потому что размер типа `void` не определён (0 байт). Компилятор не знает, на сколько байт сдвигать указатель при операциях `+` или `-`. Нужно явно привести к конкретному типу:
```c
void* ptr;
// ptr + 1; // ОШИБКА!
((char*)ptr) + 1; // правильно
```

#### 36. Как объявить указатель на массив из 10 int?
```c
int (*ptr)[10];
```
Круглые скобки важны: `int (*ptr)[10]` - указатель на массив из 10 int, а `int* ptr[10]` - массив из 10 указателей на int.

#### 37. Что вернёт выражение `p + 1`, если p — указатель на int и указывает на адрес 1000?
Вернёт адрес 1004 (на большинстве систем, где `sizeof(int) = 4`). При арифметике указателей учитывается размер типа:
`p + n = адрес_p + n * sizeof(тип)`

#### 38. В чём разница между `int* const p` и `const int* p`?
- `int* const p`: константный указатель (нельзя изменить адрес, но можно изменить значение)
- `const int* p`: указатель на константу (можно изменить адрес, но нельзя изменить значение через этот указатель)
```c
int a = 1, b = 2;
int* const p1 = &a;    // p1 должен быть инициализирован
// p1 = &b;  // ОШИБКА: нельзя изменить p1
*p1 = 3;     // OK: можно изменить значение

const int* p2 = &a;
p2 = &b;     // OK: можно изменить p2
// *p2 = 3;  // ОШИБКА: нельзя изменить значение через p2
```

#### 39. Что произойдёт при разыменовании NULL-указателя?
Произойдёт неопределённое поведение (undefined behavior). Чаще всего - ошибка сегментации (segmentation fault) и аварийное завершение программы. Некоторые системы могут вести себя иначе.

#### 40. Как проверить, что указатель не равен NULL, перед использованием?
```c
if (pointer != NULL) {
    // безопасное использование указателя
    *pointer = value;
}
```
Или сокращённо:
```c
if (pointer) {
    *pointer = value;
}
```

#### 41. Как объявить функцию, возвращающую указатель на char?
```c
char* getString(void);
```
Функция возвращает указатель на `char`, который может указывать на строку или одиночный символ.

#### 42. Можно ли вернуть указатель на локальную переменную из функции? Почему это ошибка?
Нет, это серьёзная ошибка. Локальные переменные уничтожаются при выходе из функции (их память в стеке освобождается). Указатель будет указывать на невалидную область памяти (dangling pointer):
```c
int* badFunc() {
    int x = 10;  // локальная переменная
    return &x;   // ОШИБКА: вернём адрес уничтожаемой переменной
} // x уничтожается здесь
```

#### 43. Что такое "висячий указатель" (dangling pointer)? Приведите пример.
Висячий указатель - указатель, который ссылается на освобождённую или недействительную область памяти:
```c
int* createArray() {
    int arr[5] = {1, 2, 3, 4, 5};
    return arr;  // ОШИБКА: arr уничтожается при выходе
}

int main() {
    int* ptr = createArray();  // ptr теперь висячий
    printf("%d", ptr[0]);      // неопределённое поведение
    return 0;
}
```

#### 44. Как с помощью указателей обойти массив из 5 элементов?
```c
int arr[5] = {1, 2, 3, 4, 5};
int* p = arr;  // или int* p = &arr[0];

for (int i = 0; i < 5; i++) {
    printf("%d ", *(p + i));  // через арифметику указателей
}

// Или так:
for (int* ptr = arr; ptr < arr + 5; ptr++) {
    printf("%d ", *ptr);  // через инкремент указателя
}
```

#### 45. Зачем нужен приведение типов при работе с void*?
`void*` - универсальный указатель, но компилятор не знает, на какой тип он указывает. Приведение нужно для:
1. Арифметики указателей (как в вопросе 35)
2. Разыменования
3. Соответствия типам параметров функций
```c
void* memory = malloc(100);
int* intPtr = (int*)memory;  // приведение к int*
*intPtr = 42;                 // теперь можно разыменовать
```

## 4. Функции

#### 46. Обязательно ли объявлять прототип функции перед её вызовом в C?
В стандарте C89/C90 - да, обязательно. В C99 и новее - для функций с переменным числом аргументов (`printf`, `scanf`) прототип обязателен, для остальных - нет, но крайне рекомендуется. Без прототипа компилятор предполагает, что функция возвращает `int` и принимает неопределённые аргументы, что может вызвать ошибки.

#### 47. Как передать в функцию массив и его размер?
```c
void processArray(int arr[], int size) {
    // или: void processArray(int* arr, int size)
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
}

int main() {
    int numbers[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    processArray(numbers, 10);  // передаём массив и его размер
    return 0;
}
```

#### 48. Напишите прототип функции, принимающей строку и возвращающей её длину.
```c
size_t strlen(const char* str);
```
Функция принимает указатель на неизменяемую строку и возвращает её длину типа `size_t`.

#### 49. В чём разница между передачей параметра по значению и по указателю?
- **По значению**: функция получает копию значения. Изменения внутри функции не влияют на оригинал.
- **По указателю**: функция получает адрес переменной. Изменения через указатель влияют на оригинал.
```c
void byValue(int x) { x = 10; }      // не меняет оригинал
void byPointer(int* x) { *x = 10; }  // меняет оригинал

int main() {
    int a = 5, b = 5;
    byValue(a);      // a останется 5
    byPointer(&b);   // b станет 10
    return 0;
}
```

#### 50. Можно ли в C объявить функцию с переменным числом аргументов? Как?
Да, с помощью эллипсиса (`...`) и заголовка `<stdarg.h>`:
```c
#include <stdarg.h>
#include <stdio.h>

int sum(int count, ...) {
    int total = 0;
    va_list args;
    va_start(args, count);
    
    for (int i = 0; i < count; i++) {
        total += va_arg(args, int);
    }
    
    va_end(args);
    return total;
}

// Использование:
int result = sum(3, 10, 20, 30);  // 60
```

#### 51. Приведите пример рекурсивной функции для вычисления факториала.
```c
int factorial(int n) {
    return (n <= 1) ? 1 : n * factorial(n - 1);
}
```
Базовый случай: `factorial(0) = factorial(1) = 1`
Рекурсивный случай: `factorial(n) = n * factorial(n-1)`

#### 52. Какие риски рекурсии в C по сравнению с итерацией?
1. **Переполнение стека**: каждый рекурсивный вызов использует стековую память
2. **Производительность**: накладные расходы на вызовы функций
3. **Читаемость**: сложная рекурсия может быть труднее для понимания
4. **Оптимизация**: компиляторы лучше оптимизируют циклы

#### 53. Как вернуть из функции более одного значения?
Использовать указатели в параметрах:
```c
void getMinMax(int arr[], int size, int* min, int* max) {
    *min = *max = arr[0];
    for (int i = 1; i < size; i++) {
        if (arr[i] < *min) *min = arr[i];
        if (arr[i] > *max) *max = arr[i];
    }
}

// Использование:
int minVal, maxVal;
getMinMax(numbers, 10, &minVal, &maxVal);
```

#### 54. Что такое указатель на функцию? Объявите указатель на функцию, принимающую два int и возвращающую int.
Указатель на функцию хранит адрес функции для последующего вызова:
```c
// Объявление типа функции
int (*operation)(int, int);

// Пример функций
int add(int a, int b) { return a + b; }
int multiply(int a, int b) { return a * b; }

// Присвоение
operation = add;
int result = operation(5, 3);  // 8
operation = multiply;
result = operation(5, 3);      // 15
```

#### 55. Как вызвать функцию через указатель на неё?
```c
int (*funcPtr)(int, int) = add;  // указатель на функцию add
int result = funcPtr(10, 20);    // вызов через указатель
```

## 5. Динамическая память

#### 56. Как выделить память под 10 целых чисел с помощью malloc?
```c
int* numbers = (int*)malloc(10 * sizeof(int));
if (numbers == NULL) {
    // обработка ошибки выделения памяти
    exit(1);
}
```
Важно проверять результат на `NULL`!

#### 57. Чем calloc отличается от malloc?
- `malloc(size)`: выделяет неинициализированную память заданного размера
- `calloc(count, size)`: выделяет память под `count` элементов размера `size` каждый и инициализирует все байты нулями
```c
int* arr1 = malloc(10 * sizeof(int));   // содержит мусор
int* arr2 = calloc(10, sizeof(int));    // все элементы = 0
```

#### 58. Зачем проверять результат malloc на NULL?
`malloc` возвращает `NULL` при невозможности выделить запрошенную память. Использование `NULL`-указателя приводит к неопределённому поведению (обычно к краху программы):
```c
int* ptr = malloc(1000000000 * sizeof(int));  // очень большой размер
if (ptr == NULL) {
    fprintf(stderr, "Memory allocation failed!\n");
    exit(EXIT_FAILURE);
}
```

#### 59. Как освободить память, выделенную через malloc?
С помощью функции `free()`:
```c
int* ptr = malloc(100 * sizeof(int));
// использование памяти...
free(ptr);  // освобождение
ptr = NULL; // хорошая практика: обнулить указатель
```

#### 60. Что произойдёт, если дважды вызвать free для одного указателя?
Неопределённое поведение (undefined behavior). Чаще всего - крах программы (double free error). Может также привести к повреждению кучи (heap corruption).

#### 61. Можно ли вызвать free для указателя, не полученного через malloc/calloc/realloc?
Нет. `free()` можно вызывать только для указателей, полученных из функций выделения памяти, или для `NULL`. Вызов `free()` для других указателей (например, адреса локальной переменной) приводит к неопределённому поведению.

#### 62. Как изменить размер уже выделенного блока памяти?
С помощью `realloc()`:
```c
int* ptr = malloc(5 * sizeof(int));
// нужно больше памяти...
int* newPtr = realloc(ptr, 10 * sizeof(int));
if (newPtr == NULL) {
    // ошибка, ptr остаётся валидным
    free(ptr);
} else {
    ptr = newPtr;  // успешно, старый указатель может быть невалидным
}
```
`realloc` может переместить блок в памяти, поэтому старый указатель может стать невалидным.

#### 63. Почему sizeof не работает для определения размера динамического массива?
`sizeof` возвращает размер типа или объекта на этапе компиляции. Для указателя он возвращает размер самого указателя (например, 8 байт на 64-битной системе), а не размер выделенной памяти:
```c
int* arr = malloc(100 * sizeof(int));
printf("%zu\n", sizeof(arr));  // 8 (размер указателя), не 400!
```
Размер динамически выделенной памяти нужно хранить отдельно.

#### 64. Что такое утечка памяти? Приведите пример в коде.
Утечка памяти - ситуация, когда выделенная память не освобождается, но на неё больше нет ссылок:
```c
void leakMemory() {
    int* ptr = malloc(100 * sizeof(int));
    // использование ptr...
    // ОШИБКА: нет free(ptr)!
} // ptr уничтожается, но память не освобождена

// Или так:
while (1) {
    int* data = malloc(1024);  // выделяем каждый цикл
    // нет free(data) - утечка на каждой итерации
}
```

#### 65. Как правильно освободить память под массив указателей на строки?
```c
// 1. Сначала освободить каждую строку
for (int i = 0; i < count; i++) {
    free(array[i]);  // Освобождаем каждую строку
    array[i] = NULL; // Опционально, но хорошая практика
}

// 2. Потом освободить сам массив указателей
free(array);
array = NULL; // Чтобы не использовать после освобождения
```

## 6. Препроцессор и компиляция

#### 66. Назовите 4 этапа компиляции программы на C.
1. **Препроцессинг**: обработка директив `#include`, `#define`, `#ifdef` и т.д.
2. **Компиляция**: преобразование C-кода в ассемблерный код
3. **Ассемблирование**: преобразование ассемблерного кода в объектный код
4. **Линковка**: связывание объектных файлов и библиотек в исполняемый файл

#### 67. Какая утилита отвечает за препроцессинг? Какой флаг GCC останавливает компиляцию на этом этапе?
Препроцессор - `cpp` (C Preprocessor). Флаг `-E` для GCC:
```bash
gcc -E program.c -o program.i
```
Создаёт файл с расширением `.i`, содержащий результат препроцессинга.

#### 68. Что делает директива `#include <stdio.h>`?
Включает содержимое стандартного заголовочного файла `stdio.h` в текущий исходный файл на этапе препроцессинга. Этот файл содержит объявления функций ввода/вывода (`printf`, `scanf` и др.), типы и макросы.

#### 69. В чём разница между `#include "file.h"` и `#include <file.h>`?
- `#include "file.h"`: сначала ищет в текущей директории, затем в стандартных путях
- `#include <file.h>`: ищет только в стандартных путях (системных директориях)

#### 70. Как создать условную компиляцию с помощью `#ifdef`?
```c
// 1. Определяем макрос (обычно в Makefile или командной строке)
#define DEBUG  // или компиляция с флагом: gcc -DDEBUG program.c

// 2. Проверяем в коде
#ifdef DEBUG
    // Этот код попадёт в программу ТОЛЬКО если DEBUG определён
    printf("Отладочное сообщение: x = %d\n", x);
    log_to_file("Функция вызвана");
#endif

// 3. Альтернатива с #else
#ifdef DEBUG
    printf("Отладка включена\n");
#else
    printf("Отладка выключена\n");
#endif

// 4. Проверка на отсутствие
#ifndef RELEASE
    printf("Это не релизная версия\n");
#endif
```

#### 71. Что делает `#pragma once` и зачем он нужен?
`#pragma once` - нестандартная, но широко поддерживаемая директива, которая гарантирует, что заголовочный файл будет включён только один раз:
```c
// file.h
#pragma once
// содержимое заголовочного файла
```
Альтернатива - использование стражей включения (include guards):
```c
#ifndef FILE_H
#define FILE_H
// содержимое
#endif
```

#### 72. Как посмотреть, какие макросы определены в системе при компиляции?
Использовать флаги компилятора:
```bash
gcc -dM -E - < /dev/null  # вывести все предопределённые макросы
gcc -E -dD program.c      # вывести макросы после препроцессинга
```
Или в коде:
```c
#ifdef __linux__
    printf("Compiling on Linux\n");
#endif
```

## 7. Файловый ввод/вывод

#### 73. Как открыть файл только для чтения?
```c
FILE* file = fopen("filename.txt", "r");
if (file == NULL) {
    perror("Error opening file");
    return 1;
}
```
Режим `"r"` - чтение текстового файла. Для бинарного: `"rb"`.

#### 74. Как проверить, успешно ли открылся файл?
Проверить возвращаемое значение `fopen()` на `NULL`:
```c
FILE* fp = fopen("data.txt", "r");
if (fp == NULL) {
    fprintf(stderr, "Cannot open file: %s\n", strerror(errno));
    exit(EXIT_FAILURE);
}
```
Или использовать `perror()` для вывода системного сообщения об ошибке.

#### 75. Как прочитать строку из файла с возможностью чтения пробелов?
Использовать `fgets()` вместо `fscanf()`:
```c
char buffer[256];
while (fgets(buffer, sizeof(buffer), file) != NULL) {
    printf("%s", buffer);  // читает строку с пробелами
}
```
`fgets()` читает до символа новой строки или до заполнения буфера.

#### 76. В чём разница между текстовым и бинарным режимом открытия файла?
- **Текстовый режим** (`"r"`, `"w"`, `"a"`): преобразует символы конца строки (например, `\r\n` → `\n` в Windows)
- **Бинарный режим** (`"rb"`, `"wb"`, `"ab"`): чтение/запись без преобразований, побайтово
```c
// Для текстовых данных:
FILE* text = fopen("file.txt", "w");
// Для бинарных данных (структуры, изображения):
FILE* binary = fopen("data.bin", "wb");
```

#### 77. Как записать структуру в бинарный файл?
```c
struct Record {
    int id;
    char name[50];
    float salary;
};

struct Record rec = {1, "John Doe", 50000.0f};
FILE* file = fopen("data.bin", "wb");
if (file != NULL) {
    fwrite(&rec, sizeof(struct Record), 1, file);
    fclose(file);
}
```
`fwrite` записывает структуру побайтово.

#### 78. Почему важно вызывать fclose()?
1. **Буферизация**: данные могут оставаться в буфере, `fclose()` гарантирует их запись
2. **Дескрипторы файлов**: операционная система ограничивает количество открытых файлов
3. **Целостность данных**: предотвращает потерю данных при аварийном завершении
4. **Блокировки**: закрытие файла снимает возможные блокировки

#### 79. Как определить, достигнут ли конец файла при чтении?
Использовать `feof()` или проверять результат функций чтения:
```c
// Способ 1: проверка feof()
while (!feof(file)) {
    // чтение...
}

// Способ 2: проверка результата fread/fgets (лучше!)
char buffer[100];
while (fgets(buffer, sizeof(buffer), file) != NULL) {
    // обработка строки
}

// Для fread:
size_t items;
while ((items = fread(buffer, sizeof(buffer[0]), count, file)) > 0) {
    // обработка items элементов
}
```

#### 80. Как обработать ошибку при записи в файл, если диск заполнен?
Проверять возвращаемые значения функций записи:

```c
if (fflush(file) == EOF) {
    // 1. Вызываем fflush(file) - пытаемся записать буфер на диск
    // 2. Сравниваем результат с EOF (End Of File, обычно -1)
    // 3. Если fflush вернул EOF - произошла ошибка
    // 4. Заходим внутрь блока if
    
    if (errno == ENOSPC) {
        // 5. Проверяем глобальную переменную errno
        // 6. ENOSPC = "Error NO SPace" (код ошибки "нет места")
        // 7. Если errno содержит этот код - значит диск заполнен
        // 8. Заходим внутрь вложенного блока if
        
        printf("Нет места на диске\n");
        // 9. Выводим сообщение об ошибке
    }
}
```
