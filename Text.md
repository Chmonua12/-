# Контрольные вопросы по дисциплине «Разработка программных модулей и приложений для серверов»

## 1. Опишите кратко суть клиент-серверного взаимодействия на примере протокола HTTP. Каковы основные компоненты HTTP-запроса и ответа?

**Ответ:** Клиент-серверная архитектура — это модель распределённой системы, где клиент (программа-инициатор, например, браузер) отправляет запросы на удалённый сервер (программа-обработчик), который предоставляет ресурсы или услуги. Протокол HTTP (HyperText Transfer Protocol) является текстовым протоколом прикладного уровня, который формализует это взаимодействие для передачи веб-контента. Клиент формирует и отправляет HTTP-запрос, сервер принимает его, выполняет необходимую логику и возвращает HTTP-ответ.

**Основные компоненты HTTP-запроса:**
- **Стартовая строка (Request Line):** Содержит метод (GET — получить данные, POST — отправить данные), путь к ресурсу (URL) и версию протокола
- **Заголовки (Headers):** Мета-информация о запросе: тип принимаемых данных, cookies, информация о клиенте
- **Тело запроса (Body):** Необязательная часть, содержащая данные для отправки на сервер (поля формы в JSON, XML)

**Основные компоненты HTTP-ответа:**
- **Строка статуса (Status Line):** Содержит версию протокола, код состояния (200 — OK, 404 — Not Found) и поясняющую фразу
- **Заголовки (Headers):** Мета-информация о ответе: тип контента, размер, настройки кеширования
- **Тело ответа (Body):** Основные данные, запрошенные клиентом (HTML-страница, JSON, файл)

**Интересный факт:** HTTP изначально был stateless (не сохраняющим состояние) — сервер «забывал» клиента после ответа. Для поддержания сессий были изобретены механизмы вроде cookies, которые клиент добровольно хранит и отправляет с каждым запросом.

## 2. Что такое сокет (socket) в программировании? Опишите минимальную последовательность шагов для создания простого TCP-сервера, ожидающего подключений.

**Ответ:** Сокет — это программный интерфейс, предоставляемый операционной системой, который позволяет программам обмениваться данными по сети. Это конечная точка канала связи, объединяющая IP-адрес хоста и номер порта. Проще говоря, это «дверь» в программу, через которую можно принять или отправить сетевые данные.

**Минимальная последовательность шагов для создания TCP-сервера:**
1. **Создание сокета:** Инициализация сетевого интерфейса с указанием семейства адресов (IPv4) и типа протокола (TCP)
2. **Привязка к адресу и порту:** Связывание сокета с конкретным IP-адресом и портом, на котором сервер будет принимать соединения
3. **Начало прослушивания:** Перевод сокета в режим ожидания входящих подключений с указанием максимального размера очереди
4. **Принятие входящего соединения:** Блокирующий вызов, который ожидает подключения клиента и возвращает новый сокет для общения с этим клиентом
5. **Обмен данными:** Чтение данных от клиента и отправка ответа через полученный сокет
6. **Закрытие соединений:** Закрытие клиентского сокета после завершения общения и основного сокета при завершении работы сервера

**Интересный факт:** Сокеты — фундаментальная абстракция, лежащая в основе почти всего сетевого взаимодействия в интернете. Ваш веб-сервер, база данных и Django-приложение в конечном счёте используют сокеты для связи друг с другом и с внешним миром, хотя и через множество слоёв абстракции.

## 3. В чём состоит принципиальная разница между синхронной и асинхронной моделью обработки запросов на сервере? Какие преимущества и сложности у каждого подхода?

**Ответ:** Разница заключается в том, как сервер ожидает завершения операций ввода-вывода, таких как запрос к БД, чтение файла или вызов внешнего API.

**Синхронная модель (блокирующая):**
- **Принцип:** Поток выполнения сервера останавливается на время выполнения любой I/O-операции, ожидая её завершения, не делая ничего другого
- **Преимущества:** Простота понимания и отладки, отсутствие проблем с состоянием гонки в рамках одного потока
- **Сложности:** Низкая эффективность при высокой нагрузке, необходимость создания множества потоков или процессов для обслуживания клиентов

**Асинхронная модель (неблокирующая):**
- **Принцип:** Один поток может обрабатывать множество соединений одновременно, откладывая I/O-операции и переключаясь между готовыми задачами через механизм событийной петли
- **Преимущества:** Высокая производительность для I/O-нагруженных задач, экономия ресурсов ОС
- **Сложности:** Сложнее в разработке и отладке, требует специальных асинхронных фреймворков и библиотек

**Интересный факт:** Асинхронность выигрывает в пропускной способности — количестве запросов, которые сервер может обработать в единицу времени при высокой параллельной нагрузке. Для вычислений, нагружающих CPU, асинхронность преимуществ не даёт.

## 4. Что такое SQL-инъекция (SQL Injection) и какие базовые меры защиты от неё должен предусмотреть разработчик серверной части?

**Ответ:** SQL-инъекция — это критическая уязвимость веб-безопасности, которая позволяет злоумышленнику вмешиваться в запросы, которые приложение отправляет к базе данных. Это происходит, когда пользовательский ввод некорректно обрабатывается и напрямую подставляется в SQL-запрос, позволяя выполнить произвольный SQL-код.

**Базовые меры защиты:**
1. **Использование параметризованных запросов:** Самый надёжный метод, когда SQL-запрос и данные передаются в СУБД отдельно через плейсхолдеры
2. **Использование ORM:** Object-Relational Mapper по умолчанию использует параметризованные запросы, минимизируя риск инъекций
3. **Валидация и экранирование ввода:** Принятие только ожидаемых типов данных и использование встроенных функций экранирования конкретной СУБД
4. **Принцип наименьших привилегий:** Учётная запись приложения в БД должна иметь строго ограниченные права

**Интересный факт:** Первая крупная атака с использованием SQL-инъекции была зафиксирована в 1998 году. Несмотря на то, что эта уязвимость известна уже более 25 лет, она по-прежнему регулярно встречается в веб-приложениях и входит в топ уязвимостей OWASP Top 10.

## 5. Опишите архитектурный паттерн MVT (Model-View-Template), используемый в Django. Какую роль играет каждый из этих компонентов в обработке пользовательского запроса?

**Ответ:** MVT — это вариация классического паттерна MVC, адаптированная под идеологию Django. Его цель — разделение ответственности в приложении.

**Роль компонентов:**
- **Model (Модель):** Отвечает за данные и бизнес-логику. Определяет структуру данных, валидацию, связи между сущностями. В обработке запроса View обращается к Model для получения, сохранения или изменения данных
- **View (Представление):** Обработчик запроса. Получает HTTP-запрос, выполняет необходимую логику, выбирает подходящий Template для отображения и возвращает HTTP-ответ. Связывает Model и Template
- **Template (Шаблон):** Отвечает за презентационный слой. Это HTML-файл с шаблонным языком, который описывает как выглядят данные, но не содержит бизнес-логику

**Поток обработки запроса:** URL → View (запрашивает данные) → Model (работает с БД) → View (получает данные, передаёт в шаблон) → Template (генерирует HTML) → View (возвращает HTTP-ответ)

**Интересный факт:** Путаница между MVC и MVT возникает из-за разницы в терминологии. То, что в Django называется View (обработчик запроса), в классическом MVC называется Controller. А то, что в MVC называется View (отображение), в Django — Template.

## 6. Каковы ключевые преимущества использования ORM (Object-Relational Mapper) Django по сравнению с написанием "сырых" SQL-запросов? Приведите пример возможного недостатка ORM.

**Ответ:** ORM — это технология, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, позволяя работать с данными как с объектами Python.

**Ключевые преимущества Django ORM:**
1. **Производительность разработки:** Не нужно писать и отлаживать многословные SQL-запросы для типовых операций
2. **Безопасность:** Автоматическое использование параметризованных запросов, исключающее риск SQL-инъекций
3. **Абстракция от БД:** Код в основном переносим между разными СУБД
4. **Удобство работы со связями:** Легко работать со связанными объектами без сложных JOIN-запросов
5. **Встроенная система миграций:** Автоматическое отслеживание изменений в моделях

**Пример недостатка ORM:**
Падение производительности на сложных запросах. ORM может сгенерировать неоптимальный SQL-запрос для сложной выборки с множественными условиями и агрегациями. Например, проблема N+1 Query: при получении списка статей и их авторов неоптимизированный код может выполнить один запрос для списка статей и затем по отдельному запросу для автора каждой статьи.

**Интересный факт:** Современные ORM — это сложные системы с собственными «компиляторами» запросов. Они трансформируют цепочки методов Python-кода в абстрактное синтаксическое дерево, а затем «собирают» его в корректный SQL для конкретной базы данных.

## 7. Опишите основные типы связей между моделями в Django (OneToOne, ForeignKey, ManyToMany). Приведите по одному практическому примеру для каждого типа.

**Ответ:** Django ORM предоставляет три основных типа полей для организации связей между таблицами в реляционной БД.

**OneToOneField (один-к-одному):**
- **Суть:** Строгое соответствие «одна запись модели А связана ровно с одной записью модели Б, и наоборот»
- **Пример:** Профиль пользователя. У одного пользователя может быть только один расширенный профиль, и этот профиль принадлежит только одному пользователю

**ForeignKey (внешний ключ, один-ко-многим):**
- **Суть:** Самая частая связь. «Одна запись модели А может быть связана со многими записями модели Б»
- **Пример:** Автор и статьи. Один автор может написать много статей, но каждая статья имеет ровно одного автора

**ManyToManyField (многие-ко-многим):**
- **Суть:** «Одна запись модели А может быть связана со многими записями модели Б, и одна запись модели Б может быть связана со многими записями модели А»
- **Пример:** Статьи и теги. Одна статья может иметь несколько тегов, и один тег может быть присвоен многим статьям

**Интересный факт:** ManyToManyField может быть объявлена с опцией through, которая позволяет создать собственную модель для промежуточной таблицы. Это нужно, если нужно хранить дополнительную информацию о связи.

## 8. Как Django определяет, какое представление (view) должно обработать конкретный URL-запрос пользователя? Опишите роль файла urls.py и функции path().

**Ответ:** Django использует конфигурацию URL (URLconf) — иерархию Python-модулей, которые сопоставляют шаблоны URL с обработчиками.

**Роль urls.py:** Это главный конфигурационный файл маршрутизации для приложения или проекта. Содержит переменную urlpatterns — список путей, определённых функцией path().

**Роль path():** Функция, которая регистрирует конкретное правило сопоставления:
- Первый аргумент: строка маршрута — шаблон URL
- Второй аргумент: объект view — функция- или класс-представление
- Третий аргумент: name — уникальное имя для URL для обратного разрешения

**Процесс определения (URL dispatcher):**
1. При получении запроса Django отсекает домен и параметры запроса
2. Движок проверяет список urlpatterns в корневом urls.py
3. Последовательно сравнивает путь с каждым шаблоном
4. При нахождении совпадения вызывает связанное view с извлечёнными данными как аргументы
5. Если совпадений не найдено, вызывается view для обработки ошибки 404

**Интересный факт:** URLconf обрабатывается последовательно сверху вниз. Порядок объявления path() важен: если более общий шаблон будет объявлен после шаблона с конвертером, это может привести к неверной интерпретации запроса.

## 9. Для чего используются декораторы в контексте Function-Based Views (например, @login_required, @csrf_exempt)? Как они меняют поведение функции-представления?

**Ответ:** Декоратор в Python — это функция, которая принимает другую функцию и расширяет или изменяет её поведение, не изменяя исходный код. В контексте FBV Django декораторы — это удобный способ добавить общую функциональность к функции-представлению.

**@login_required:**
- **Что делает:** Проверяет, аутентифицирован ли текущий пользователь
- **Как меняет поведение:** Обёрнутая view-функция выполнится только для авторизованных пользователей. Для анонимных произойдёт перенаправление на страницу входа

**@csrf_exempt:**
- **Что делает:** Отключает проверку CSRF-токена для конкретного view
- **Как меняет поведение:** Позволяет view принимать POST-запросы без CSRF-токена. Используется для API-эндпоинтов, где стандартный механизм CSRF не работает

**Интересный факт:** Декораторы — это реализация паттерна проектирования Декоратор. В Django middleware и декораторы views часто решают схожие задачи. Ключевое отличие: middleware работает на уровне всего запроса/ответа и применяется глобально, а декоратор — точечно к конкретной функции.

## 10. В чём заключаются основные преимущества использования Class-Based Views (CBV) по сравнению с Function-Based Views? Назовите несколько встроенных CBV для типовых задач.

**Ответ:** CBV — это альтернативный способ организации view-логики в виде классов, а не функций.

**Основные преимущества CBV:**
1. **Повторное использование кода и наследование:** Можно создать базовый класс с общей логикой и наследовать от него
2. **Структурированность:** Логика обработки разных HTTP-методов разделяется по отдельным методам класса
3. **Использование встроенных «заготовок»:** Django предоставляет набор готовых классов для типовых задач

**Встроенные Generic CBV для типовых задач:**
- **ListView:** Для отображения списка объектов из QuerySet
- **DetailView:** Для отображения детальной информации об одном объекте
- **CreateView, UpdateView, DeleteView:** Для создания, обновления и удаления объектов с использованием форм
- **TemplateView:** Для отображения статического шаблона

**Интересный факт:** CBV в Django построены на принципе «конвейера методов». При обработке запроса вызывается цепочка методов, что позволяет гибко настраивать поведение, переопределяя нужные методы. Мощь CBV раскрывается при работе с миксинами.

## 11. Как работает механизм наследования шаблонов в Django? Объясните назначение тегов {% block %} и {% extends %} и их роль в поддержке единого дизайна сайта.

**Ответ:** Механизм наследования шаблонов позволяет создавать иерархию шаблонов, что избавляет от дублирования кода и поддерживает единый дизайн сайта.

**{% extends "base.html" %}:**
- **Назначение:** Объявляет, что текущий шаблон является дочерним и наследует всё содержимое от указанного родительского шаблона
- **Как работает:** Движок шаблонов сначала загружает и рендерит родительский шаблон, но вместо статического содержимого в определённых местах подставляет блоки из дочернего шаблона

**{% block content %} ... {% endblock %}:**
- **Назначение:** Определяет блок, который может быть переопределён в дочерних шаблонах
- **В родительском шаблоне:** Содержит контент по умолчанию
- **В дочернем шаблоне:** Переопределяет одноимённый блок из родителя

**Интересный факт:** Можно создавать целые цепочки наследования. Также внутри блока можно использовать {{ block.super }} для вставки содержимого этого же блока из родительского шаблона, что полезно для добавления, а не полной замены контента.

## 12. Каковы основные элементы синтаксиса Django Template Language (DTL)? Приведите примеры использования переменной, тега и фильтра, объяснив их отличие.

**Ответ:** DTL — это специальный язык с ограниченной логикой, предназначенный для вставки данных в HTML.

**Основные элементы:**
1. **Переменные (Variables):** Синтаксис: {{ variable_name }}
   - **Назначение:** Вывод значения переменной, переданной в контекст шаблона
   - **Пример:** {{ article.title }} выведет заголовок статьи

2. **Теги (Tags):** Синтаксис: {% tag_name %} ... {% endtag_name %}
   - **Назначение:** Выполняют логику: циклы, условия, загрузка других шаблонов
   - **Примеры:** {% for item in list %} ... {% endfor %}, {% if condition %} ... {% endif %}

3. **Фильтры (Filters):** Синтаксис: {{ variable|filter_name:argument }}
   - **Назначение:** Изменяют значение переменной для отображения
   - **Примеры:** {{ title|lower }}, {{ pub_date|date:"d.m.Y" }}, {{ text|truncatechars:100 }}

**Главное отличие:** Теги — это логика и управление. Фильтры — это преобразования данных для вывода. Переменные — это сами данные.

**Интересный факт:** DTL намеренно ограничен. В нём нельзя вызывать функции с аргументами или выполнять произвольный Python-код. Это философское решение в угоду безопасности и разделению ответственности.

## 13. Опишите жизненный цикл Django-формы: от момента создания в представлении до сохранения данных. Какие основные этапы обработки проходит форма?

**Ответ:** Форма в Django обрабатывает пользовательский ввод. Её жизненный цикл состоит из нескольких этапов.

**Основные этапы обработки:**
1. **Создание формы в представлении:** Для GET-запроса создаётся пустая форма, для POST — форма, связанная с данными из request.POST
2. **Валидация данных:** Вызов метода is_valid() запускает процесс валидации: проверка полей, очистка данных, валидация формы в целом
3. **Проверка результата валидации:** Если форма валидна, данные в cleaned_data готовы к использованию. Если нет — форма возвращается с ошибками
4. **Обработка валидных данных:** Разработчик берёт cleaned_data и сохраняет в базу, отправляет email и т.д.
5. **Редирект (Post/Redirect/Get pattern):** После успешной обработки POST-запроса всегда следует возвращать HTTP-редирект

**Интересный факт:** Паттерн Post/Redirect/Get — стандартная практика в веб-разработке. После успешного POST сервер отправляет браузеру команду «иди по этому другому URL». Браузер выполняет GET-запрос. Таким образом, история браузера содержит GET-запрос, и его обновление не приводит к повторному POST.

## 14. В чём разница между классами Form и ModelForm? В какой ситуации целесообразно использовать каждый из них?

**Ответ:** Оба класса используются для создания и обработки HTML-форм, но имеют разную область применения.

**django.forms.Form (обычная форма):**
- **Назначение:** Создание формы для сбора данных, которые не привязаны напрямую к одной конкретной модели
- **Примеры использования:** Форма поиска, форма входа/регистрации, форма обратной связи
- **Создание:** Поля формы описываются вручную в классе

**django.forms.ModelForm (форма модели):**
- **Назначение:** Создание формы, которая напрямую связана с конкретной моделью Django
- **Ключевая особенность:** Автоматически генерирует поля формы на основе полей модели
- **Пример использования:** Админка Django, CRUD-интерфейс для сущностей
- **Создание:** Указывается модель, на основе которой нужно создать форму

**Вывод:** Используйте ModelForm, когда нужно быстро создать интерфейс для работы с записью в базе данных. Используйте обычную Form, когда данные формы предназначены для других целей или требуют сложной обработки.

**Интересный факт:** ModelForm сам является подклассом Form. Он автоматически создаёт объекты полей forms.Form, анализируя модель. Вы всегда можете добавить в ModelForm дополнительные поля или переопределить автоматически созданные.

## 15. Какую основную проблему решает сериализатор (Serializer) в Django REST Framework? Опишите его две ключевые функции.

**Ответ:** **Проблема:** В REST API данные передаются в формате JSON, а в приложении на Django они существуют в виде сложных объектов Python. Необходим механизм для двустороннего преобразования.

**Сериализатор в DRF** решает именно эту проблему.

**Его две ключевые функции:**
1. **Сериализация:** Преобразование сложных типов данных (модели Django, QuerySet) в примитивные типы, которые можно легко преобразовать в JSON
2. **Десериализация:** Преобразование входящих данных (обычно JSON), их валидация и создание на их основе объектов Python

**Важно:** Вторая функция — валидация — является критически важной частью десериализации. Сериализатор проверяет типы данных, обязательность полей, соответствие ограничениям.

**Интересный факт:** Сериализаторы DRF очень гибки. Они могут сериализовать не только модели, но и любые объекты. С их помощью можно формировать ответы API, которые агрегируют данные из нескольких источников.

## 16. В чём заключается идея и преимущество использования ViewSet и Router в DRF по сравнению с написанием отдельных представлений для каждой операции API?

**Ответ:** **Проблема:** При создании классического REST API для сущности нужно написать несколько отдельных view для каждой операции, затем все их прописать в urls.py.

**ViewSet** — это абстракция в DRF, которая объединяет логику для набора связанных операций над одной сущностью в одном классе.

**Router** — это инструмент, который автоматически генерирует URL-конфигурацию для зарегистрированного ViewSet.

**Преимущества:**
1. **Сокращение шаблонного кода:** Логика для одной сущности группируется
2. **Автоматическая генерация URL:** Роутер создаёт стандартные URL
3. **Согласованность API:** Гарантируется, что URL и имена эндпоинтов будут следовать REST-соглашениям
4. **Простота расширения:** На основе базового ModelViewSet можно быстро создать полнофункциональный CRUD

**Интересный факт:** ViewSet сам по себе не является view, пока не будет «привязан» к конкретным URL. Этим занимается роутер, который динамически создаёт настоящие view-функции для каждого HTTP-метода.

## 17. Объясните концепцию аутентификации на основе JWT-токенов. Каковы его основные преимущества для API перед традиционной сессионной аутентификацией?

**Ответ:** JWT (JSON Web Token) — это открытый стандарт для создания токенов доступа, основанный на JSON.

**Концепция:**
1. Пользователь отправляет учётные данные на эндпоинт аутентификации
2. Сервер проверяет данные и формирует подписанный JWT-токен
3. Токен возвращается клиенту
4. Клиент отправляет токен в заголовке Authorization с каждым запросом
5. Сервер проверяет подпись и срок действия токена, извлекает данные о пользователе

**Основные преимущества JWT для API:**
1. **Stateless (бессостоятельность):** Серверу не нужно хранить состояние сессии
2. **Идеально для распределённых систем:** Токен может быть проверен любым сервисом, у которого есть секретный ключ
3. **Поддержка мобильных клиентов:** Не зависит от браузерных кук
4. **Гибкость:** В payload можно поместить любые данные

**Недостатки:** Невозможность отозвать токен до истечения срока, увеличенный размер запроса, риск кражи токена.

**Интересный факт:** Подпись JWT гарантирует целостность данных, но не обеспечивает конфиденциальность. Payload можно легко прочитать. Поэтому в JWT нельзя помещать чувствительные данные.

## 18. Какие встроенные механизмы защиты от CSRF и XSS атак предоставляет Django и как они работают на базовом уровне?

**Ответ:** Django имеет мощную защиту «из коробки».

**Защита от CSRF:**
- **Суть атаки:** Злоумышленник заставляет браузер авторизованного пользователя выполнить нежелательный запрос на доверенный сайт
- **Механизм защиты:** CSRF middleware, использование CSRF-токенов
- **Как работает:** При генерации формы создаётся уникальный CSRF-токен, который добавляется как скрытое поле и сохраняется в куки. При отправке формы сравниваются токен из поля и токен из куки

**Защита от XSS:**
- **Суть атаки:** Внедрение вредоносного JavaScript-кода на страницу
- **Механизмы защиты:** Автоматическое экранирование в шаблонах, тег |safe и mark_safe(), валидация форм
- **Как работает:** DTL автоматически экранирует все переменные, заменяя опасные символы на безопасные HTML-сущности

**Интересный факт:** Автоматическое экранирование — главный щит Django от XSS, но оно не всесильно. XSS возможен, если разработчик явно помечает как safe ненадёжные данные или если вредоносный код попадает в контекст, где HTML-экранирование бесполезно.

## 19. Опишите типичный production-стек для развертывания Django-приложения. Какую роль в нём выполняют веб-сервер (Nginx) и сервер приложений (Gunicorn)?

**Ответ:** В production Django-приложение никогда не должно работать на встроенном сервере для разработки. Используется стек из нескольких специализированных компонентов.

**Типичный стек:**
Клиент ↔ Nginx ↔ Gunicorn ↔ Django Application ↔ База данных ↔ Кеш

**Роль Nginx:**
- Внешний интерфейс, принимает HTTP/HTTPS-запросы
- Обработка статических файлов
- Проксирование динамических запросов серверу приложений
- SSL-терминирование, сжатие, кеширование

**Роль Gunicorn:**
- Получает проксированные запросы от Nginx
- Управляет воркерами — отдельными экземплярами Python-процессов
- Распределяет запросы между воркерами

**Поток запроса:** Клиент → Nginx → (если статика: отдача; если динамика: прокси) → Gunicorn → Воркер (Django) → БД → Обратно по цепочке

**Интересный факт:** Для асинхронных приложений на Django вместо Gunicorn используется Uvicorn или Daphne — ASGI-серверы, которые умеют эффективно работать с асинхронным кодом.

## 20. В чём заключаются ключевые преимущества использования Docker для деплоя серверного приложения? Опишите эту концепцию на уровне контейнеризации.

**Ответ:** Docker — это платформа для разработки, доставки и запуска приложений в изолированных средах, называемых контейнерами.

**Концепция контейнеризации:**
Контейнер — это не виртуальная машина. Все контейнеры на хосте разделяют ядро основной ОС. Контейнер включает:
- Приложение
- Все его зависимости
- Конфигурацию среды
- Только самое необходимое из пользовательского пространства ОС

**Ключевые преимущества для деплоя:**
1. **Гарантированная консистентность окружения:** «У меня работает, а на сервере — нет» больше не проблема
2. **Изоляция и безопасность:** Приложение работает изолированно от других на том же хосте
3. **Легкость развертывания и масштабирования:** Образ Docker — готовый к запуску пакет
4. **Эффективное использование ресурсов:** Контейнеры легковесны, запускаются за секунды
5. **Упрощение CI/CD:** Образ становится артефактом сборки

**Интересный факт:** Docker использует технологию наслоения образов. Каждая инструкция в Dockerfile создаёт новый слой. Если изменить код приложения и пересобрать образ, пересобираются только изменённые слои.
